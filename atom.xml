<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MORIARTY</title>
  <subtitle>A problem has been detected</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daiyongya.github.io/"/>
  <updated>2018-06-15T10:40:38.082Z</updated>
  <id>https://daiyongya.github.io/</id>
  
  <author>
    <name>NOBODY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linear regression based on Gibbs sampling</title>
    <link href="https://daiyongya.github.io/2018/06/15/Gibbs%20sampling/"/>
    <id>https://daiyongya.github.io/2018/06/15/Gibbs sampling/</id>
    <published>2018-06-14T16:28:06.000Z</published>
    <updated>2018-06-15T10:40:38.082Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="Bayesian-linear-regression"><a href="#Bayesian-linear-regression" class="headerlink" title="Bayesian linear regression"></a>Bayesian linear regression</h2><p>此实例为吉布斯采样基于线性回归的实现。<br><a id="more"></a><br>$(y<em>{i},x</em>{i}),i=1,\cdots ,N $,以及$ y<em>{i}\sim \mathcal{N}(\beta </em>{0}+\beta<em>{1}x</em>{i},1/\tau )$<br>假设我们已经知道实数对,根据分布的性质，也可以写成另外一种形式，$ y<em>{i}=\beta </em>{0}+\beta<em>{1}x</em>{i}+\epsilon,\epsilon\sim \mathcal{N}(0,1/\tau ) $,假设观察到的实数对相互独立的产生于同一个分布，其似然函数可以写成：</p>
<p>$L(y<em>{1},\cdots ,y</em>{n},x<em>{1},\cdots,x</em>{n}\setminus \beta <em>{0},\beta</em>{1},\tau)=\prod<em>{i=1}^{N}\mathcal{N}(\beta</em>{0}+\beta<em>{1}x</em>{i},1/\tau)$<br>为了便于计算，我们对参数取共轭先验：</p>
<p>$\beta<em>{0}\sim \mathcal{N}(\mu </em>{0},1/\tau<em>{0})\\beta</em>{1}\sim \mathcal{N}(\mu <em>{1},1/\tau</em>{1})\\tau \sim Gamma(\alpha ,\beta )$<br>这里有详细的slices推导，<a href="http://www.cs.toronto.edu/~radford/csc2541.S11/week3.pdf" target="_blank" rel="external">请点击</a></p>
<h2 id="Gibbs基本方法介绍"><a href="#Gibbs基本方法介绍" class="headerlink" title="Gibbs基本方法介绍"></a>Gibbs基本方法介绍</h2><p>我们有两个参数$\theta<em>{1},\theta</em>{2}$，以及观测数据$x$，为了找到后验概率$p(\theta<em>{1},\theta</em>{2}\setminus x)$，我们做以下操作：</p>
<p>1.以一定方法初始化$\theta_{2}^{i}$(比如随机初始化)</p>
<p>2.此时根据已知采样$\theta<em>{1}^{i+1}\sim p(\theta</em>{1}\setminus\theta_{2}^{i}, x)$</p>
<p>3.根据最新的值再采样$\theta<em>{2}^{i+1}\sim p(\theta</em>{2}\setminus\theta_{1}^{i+1}, x)$</p>
<p>需要注意的是，需要交替的以最新值就行采样更新。</p>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> plt</div><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div></pre></td></tr></table></figure>
<h3 id="根据推导公式定义更新参数的函数"><a href="#根据推导公式定义更新参数的函数" class="headerlink" title="根据推导公式定义更新参数的函数"></a>根据推导公式定义更新参数的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_beta_0</span><span class="params">(y, x, beta_1, tau, mu_0, tau_0)</span>:</span></div><div class="line">    N = len(y)</div><div class="line">    <span class="keyword">assert</span> len(x) == N</div><div class="line">    precision = tau_0 + tau * N</div><div class="line">    mean = tau_0 * mu_0 + tau * np.sum(y - beta_1 * x)</div><div class="line">    mean /= precision</div><div class="line">    <span class="keyword">return</span> np.random.normal(mean, <span class="number">1</span> / np.sqrt(precision))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_beta_1</span><span class="params">(y, x, beta_0, tau, mu_1, tau_1)</span>:</span></div><div class="line">    N = len(y)</div><div class="line">    <span class="keyword">assert</span> len(x) == N</div><div class="line">    precision = tau_1 + tau * np.sum(x * x)</div><div class="line">    mean = tau_1 * mu_1 + tau * np.sum( (y - beta_0) * x)</div><div class="line">    mean /= precision</div><div class="line">    <span class="keyword">return</span> np.random.normal(mean, <span class="number">1</span> / np.sqrt(precision))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_tau</span><span class="params">(y, x, beta_0, beta_1, alpha, beta)</span>:</span></div><div class="line">    N = len(y)</div><div class="line">    alpha_new = alpha + N / <span class="number">2</span></div><div class="line">    resid = y - beta_0 - beta_1 * x</div><div class="line">    beta_new = beta + np.sum(resid * resid) / <span class="number">2</span></div><div class="line">    <span class="keyword">return</span> np.random.gamma(alpha_new, <span class="number">1</span> / beta_new)</div></pre></td></tr></table></figure>
<h3 id="产生数据"><a href="#产生数据" class="headerlink" title="产生数据"></a>产生数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##设置数据参数的真实参数</span></div><div class="line">beta_0_true = <span class="number">-1</span></div><div class="line">beta_1_true = <span class="number">2</span></div><div class="line">tau_true = <span class="number">1</span></div><div class="line"><span class="comment">##根据真实参数生成数据</span></div><div class="line">N = <span class="number">50</span></div><div class="line">x = np.random.uniform(low = <span class="number">0</span>, high = <span class="number">4</span>, size = N)</div><div class="line">y = np.random.normal(beta_0_true + beta_1_true * x, <span class="number">1</span> / np.sqrt(tau_true))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sns.stripplot(x,y)<span class="comment">#画出数据</span></div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x27826bb4c50&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## specify initial values</span></div><div class="line">init = &#123;<span class="string">"beta_0"</span>: <span class="number">0</span>,</div><div class="line">        <span class="string">"beta_1"</span>: <span class="number">0</span>,</div><div class="line">        <span class="string">"tau"</span>: <span class="number">2</span>&#125;</div><div class="line"></div><div class="line"><span class="comment">## specify hyper parameters</span></div><div class="line">hypers = &#123;<span class="string">"mu_0"</span>: <span class="number">0</span>,</div><div class="line">         <span class="string">"tau_0"</span>: <span class="number">1</span>,</div><div class="line">         <span class="string">"mu_1"</span>: <span class="number">0</span>,</div><div class="line">         <span class="string">"tau_1"</span>: <span class="number">1</span>,</div><div class="line">         <span class="string">"alpha"</span>: <span class="number">2</span>,</div><div class="line">         <span class="string">"beta"</span>: <span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">##定义Gibbs采样的主函数，把上面定义的几个函数按照逻辑组合起来形成一个采样过程</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gibbs</span><span class="params">(y, x, iters, init, hypers)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(y) == len(x)</div><div class="line">    beta_0 = init[<span class="string">"beta_0"</span>]</div><div class="line">    beta_1 = init[<span class="string">"beta_1"</span>]</div><div class="line">    tau = init[<span class="string">"tau"</span>]</div><div class="line"></div><div class="line">    trace = np.zeros((iters, <span class="number">3</span>)) <span class="comment">## trace to store values of beta_0, beta_1, tau</span></div><div class="line"><span class="comment">##按照更新过程进行参数逐一更新</span></div><div class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> range(iters):</div><div class="line">        beta_0 = sample_beta_0(y, x, beta_1, tau, hypers[<span class="string">"mu_0"</span>], hypers[<span class="string">"tau_0"</span>])</div><div class="line">        beta_1 = sample_beta_1(y, x, beta_0, tau, hypers[<span class="string">"mu_1"</span>], hypers[<span class="string">"tau_1"</span>])</div><div class="line">        tau = sample_tau(y, x, beta_0, beta_1, hypers[<span class="string">"alpha"</span>], hypers[<span class="string">"beta"</span>])</div><div class="line">        trace[it,:] = np.array((beta_0, beta_1, tau))</div><div class="line"></div><div class="line">    trace = pd.DataFrame(trace)</div><div class="line">    trace.columns = [<span class="string">'beta_0'</span>, <span class="string">'beta_1'</span>, <span class="string">'tau'</span>]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> trace</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">iters = <span class="number">1000</span><span class="comment">##采样次数</span></div><div class="line">trace = gibbs(y, x, iters, init, hypers)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trace.plot()<span class="comment">##采样得到的数据可视化</span></div></pre></td></tr></table></figure>
<pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x27826c3c908&gt;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">trace_burnt = trace[<span class="number">500</span>:<span class="number">999</span>]<span class="comment">##取后面500个采样</span></div><div class="line">hist_plot = trace_burnt.hist(bins = <span class="number">30</span>, layout = (<span class="number">1</span>,<span class="number">3</span>))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(trace_burnt.median())</div><div class="line">print(trace_burnt.std())</div></pre></td></tr></table></figure>
<pre><code>beta_0   -1.077110
beta_1    1.903947
tau       1.384544
dtype: float64
beta_0    0.229955
beta_1    0.093329
tau       0.288980
dtype: float64
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">trace[<span class="number">1</span>:<span class="number">10</span>]</div></pre></td></tr></table></figure>
<div><br><style><br>    .dataframe thead tr:only-child th {<br>        text-align: right;<br>    }<br><br>    .dataframe thead th {<br>        text-align: left;<br>    }<br><br>    .dataframe tbody tr th {<br>        vertical-align: top;<br>    }<br></style><br><table border="1" class="dataframe"><br>  <thead><br>    <tr style="text-align: right;"><br>      <th></th><br>      <th>beta_0</th><br>      <th>beta_1</th><br>      <th>tau</th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <th>1</th><br>      <td>1.317167</td><br>      <td>1.051728</td><br>      <td>0.445828</td><br>    </tr><br>    <tr><br>      <th>2</th><br>      <td>0.594940</td><br>      <td>1.256017</td><br>      <td>0.513077</td><br>    </tr><br>    <tr><br>      <th>3</th><br>      <td>0.134436</td><br>      <td>1.415097</td><br>      <td>0.769414</td><br>    </tr><br>    <tr><br>      <th>4</th><br>      <td>-0.123197</td><br>      <td>1.519084</td><br>      <td>0.968624</td><br>    </tr><br>    <tr><br>      <th>5</th><br>      <td>-0.073099</td><br>      <td>1.567300</td><br>      <td>0.633794</td><br>    </tr><br>    <tr><br>      <th>6</th><br>      <td>-0.525161</td><br>      <td>1.757552</td><br>      <td>0.974104</td><br>    </tr><br>    <tr><br>      <th>7</th><br>      <td>-0.843614</td><br>      <td>1.878984</td><br>      <td>1.751914</td><br>    </tr><br>    <tr><br>      <th>8</th><br>      <td>-0.876359</td><br>      <td>1.770635</td><br>      <td>1.376143</td><br>    </tr><br>    <tr><br>      <th>9</th><br>      <td>-0.890558</td><br>      <td>1.839191</td><br>      <td>1.723694</td><br>    </tr><br>  </tbody><br></table><br></div>



<p>此为纯翻译摘抄版本，英文参见<a href="https://kieranrcampbell.github.io/blog/2016/05/15/gibbs-sampling-bayesian-linear-regression.html" target="_blank" rel="external">Gibbs sampling for Bayesian linear regression in Python</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;Bayesian-linear-regression&quot;&gt;&lt;a href=&quot;#Bayesian-linear-regression&quot; class=&quot;headerlink&quot; title=&quot;Bayesian linear regression&quot;&gt;&lt;/a&gt;Bayesian linear regression&lt;/h2&gt;&lt;p&gt;此实例为吉布斯采样基于线性回归的实现。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://daiyongya.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="机器学习" scheme="https://daiyongya.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学习粒度选择</title>
    <link href="https://daiyongya.github.io/2017/11/14/%E5%AD%A6%E4%B9%A0%E7%B2%92%E5%BA%A6%E9%80%89%E6%8B%A9/"/>
    <id>https://daiyongya.github.io/2017/11/14/学习粒度选择/</id>
    <published>2017-11-14T11:40:55.000Z</published>
    <updated>2017-11-14T12:27:35.772Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>自我充电的时候，总需要去选择适合自己的资料，因为好的资料真的会事半功倍。随着微信、头条等碎片化知识的暴增，会感觉到一种信息泛滥，比如开始看财经板块的时候，傻傻分不清企业毛利率，企业纯利润，资金周转率，业务增长细节等问题，感觉稍感恐慌，于是乎会去百度查找相关名词，慢慢感觉懂了，不断的积累，慢慢感觉财经板块看标题就大概都懂了，觉得很厉害的样子，会增加自己的轻浮，其实很多时候都是知其然不知其所以然，社会不缺少泛泛而谈人云亦云的二愣子，缺少的是深度的理解。<br><a id="more"></a></p>
<h2 id="信息量大小"><a href="#信息量大小" class="headerlink" title="信息量大小"></a>信息量大小</h2><p>选择学习资料的时候，应根据本身所具有的先验知识具有大致的概念，知己是第一步，一个较为实用的办法就是尝试，按照机器学习算法来讲就是随机选择并暴力尝试。如果想了解机器学习算法，首先选一本书，比如经典的模式识别，如果发现难度过大，里面的概率统计没学过，或者矩阵算法没接触过，就可以选择李航的统计学习作为入门，并不是最经典的就是最适合的。如果太多知识点不了解，相对与自己来说，此资料信息量过大，自己单位时间内接受不了那么大信息量，会打消积极性甚至永远也学不完那本书，当然如果个人耐性特别好，无论信息量多大，都能在短时间接受，另当别论。选择资料，需要在信息量，学习时间，和自己耐性中作一个平衡。</p>
<h2 id="相关程度"><a href="#相关程度" class="headerlink" title="相关程度"></a>相关程度</h2><p>选择资料另外一个大忌就是知识点过长的延展，比如某大牛谈到国家经济的市场自由，中央调控力度，国家储蓄率，居民固有资产投资增长率，自然会去了解自由市场经济理论，然后去看凯恩斯，去了解杜鲁门主义，去了解美国大陆经济体系和全球贸易的利益与矛盾，再到英国脱欧的经济和政治原因，再到希腊经济的前因后果，再追溯到亚当斯密的国富论，再到美国南北战争，再到英国的工业革命，再追溯又到了西班牙葡萄牙殖民时期，再到各种帝国的兴衰荣辱。理论和历史的子子孙孙无穷尽也，自己也开始焦虑，担忧。个人认为，在短时间内学习，必须得集中精力去学习最重要得知识，找到最相关得资料，知识需要拓展，不要过于拓展，看个人学习速度及接受能力。</p>
<h2 id="个人能力"><a href="#个人能力" class="headerlink" title="个人能力"></a>个人能力</h2><p>无论什么资料，什么方法去学习，都要匹配自己个人能力，主要是个人学习速度的快慢，及学习任务的着急程度。如果是终身学习，那另当别论。按照概率分布，大部分人学习能力都是差不多，主要是适合的资料和适合的方法，这个过程需要自己试错并思考。</p>
<h2 id="知识碎片化"><a href="#知识碎片化" class="headerlink" title="知识碎片化"></a>知识碎片化</h2><p>个人认为，知识还是需要书本形式系统学习，碎片化知识作为补充。去年今年都比较火的，知乎、得到等帮忙读书等产品，很好的满足了人民走捷径的心里及表面的学习满足感，会导致个人变得浮躁，当然作为一个介绍，然后自己感兴趣再去看也是极好的。</p>
<h2 id="书本的重要性"><a href="#书本的重要性" class="headerlink" title="书本的重要性"></a>书本的重要性</h2><p>书本看起来很多冗余知识，可以浓缩成知乎、得到那些十几分钟的产品，精华可能是那些，但是直接给出那些精华，几个人能真正懂。书本的作用在于帮助人们建立一个理解事物的模型，并通过书本中冗余的信息去佐证，不断强化模型。现在最火的深度学习，也是模拟人脑，建模后大量冗余训练，减少事件的不可预知性。一句话，书本是帮助人们建模并强化模型的过程，冗余信息是完全必要的，也符合记忆曲线。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;自我充电的时候，总需要去选择适合自己的资料，因为好的资料真的会事半功倍。随着微信、头条等碎片化知识的暴增，会感觉到一种信息泛滥，比如开始看财经板块的时候，傻傻分不清企业毛利率，企业纯利润，资金周转率，业务增长细节等问题，感觉稍感恐慌，于是乎会去百度查找相关名词，慢慢感觉懂了，不断的积累，慢慢感觉财经板块看标题就大概都懂了，觉得很厉害的样子，会增加自己的轻浮，其实很多时候都是知其然不知其所以然，社会不缺少泛泛而谈人云亦云的二愣子，缺少的是深度的理解。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://daiyongya.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="学习感想" scheme="https://daiyongya.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>区块链通用功能</title>
    <link href="https://daiyongya.github.io/2017/07/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD/"/>
    <id>https://daiyongya.github.io/2017/07/13/区块链通用功能/</id>
    <published>2017-07-13T14:11:05.000Z</published>
    <updated>2017-11-14T12:38:48.198Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>区块链作为一技术架构，提供了去中心化数据服务，其中包含了较多的技术细节。<br><a id="more"></a></p>
<h2 id="链内服务"><a href="#链内服务" class="headerlink" title="链内服务"></a>链内服务</h2><ul>
<li>时间戳</li>
<li>签名证书</li>
<li>Oracles认证</li>
<li>身份认证管理</li>
<li>投票</li>
<li>智能合约管理</li>
<li>标记</li>
<li>信息</li>
<li>资产连接</li>
<li>存在性证明</li>
</ul>
<h2 id="用户视图"><a href="#用户视图" class="headerlink" title="用户视图"></a>用户视图</h2><ul>
<li>命令行</li>
<li>特殊浏览器</li>
<li>钱包</li>
<li>应用</li>
<li>可下载客户端</li>
</ul>
<h2 id="链外服务"><a href="#链外服务" class="headerlink" title="链外服务"></a>链外服务</h2><ul>
<li>声誉</li>
<li>信息</li>
<li>存储</li>
<li>交换</li>
<li>支付网关</li>
</ul>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>API</li>
<li>编程语言</li>
<li>开发环境</li>
<li>智能合约</li>
<li>测试</li>
<li>沙盘效应</li>
</ul>
<h2 id="内核协议"><a href="#内核协议" class="headerlink" title="内核协议"></a>内核协议</h2><ul>
<li>P2P网络</li>
<li>共识算法</li>
<li>虚拟机</li>
<li>历史记录</li>
<li>状态余额</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;区块链作为一技术架构，提供了去中心化数据服务，其中包含了较多的技术细节。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="商业区块链读书笔记" scheme="https://daiyongya.github.io/tags/%E5%95%86%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Blockchain技术挑战</title>
    <link href="https://daiyongya.github.io/2017/07/13/Blockchain%E6%8A%80%E6%9C%AF%E6%8C%91%E6%88%98/"/>
    <id>https://daiyongya.github.io/2017/07/13/Blockchain技术挑战/</id>
    <published>2017-07-13T14:00:31.000Z</published>
    <updated>2017-11-14T12:39:19.892Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>离开了物物交换以后，货币更多的作为一种价值载体，或是货币符号，一种信任符号，如果数字货币在不久的将来被较多人所信任能够作为价值的载体，区域链将大有可为，但也有较多挑战。<br><a id="more"></a></p>
<h2 id="技术挑战"><a href="#技术挑战" class="headerlink" title="技术挑战"></a>技术挑战</h2><ul>
<li>欠发达的基础设施；</li>
<li>缺少成熟的应用；</li>
<li>缺少更多的开发者；</li>
<li>不成熟的中间件和工具；</li>
<li>可扩展性待加强；</li>
<li>遗留系统的冲突；</li>
<li>缺乏标准；</li>
</ul>
<h2 id="商业挑战"><a href="#商业挑战" class="headerlink" title="商业挑战"></a>商业挑战</h2><ul>
<li>如何把资产转移到区块链上；</li>
<li>如何获得更多用户；</li>
<li>初创公司死亡率过高；</li>
<li>缺少标杆应用公司；</li>
<li>技术替换的成本问题；</li>
<li>创新者本身的窘境；</li>
</ul>
<h2 id="法律监管"><a href="#法律监管" class="headerlink" title="法律监管"></a>法律监管</h2><ul>
<li>监管不清晰；</li>
<li>政府干扰或者禁止；</li>
<li>炒作导致泡沫；</li>
<li>缺少税收、报告功能；</li>
</ul>
<h2 id="实施挑战"><a href="#实施挑战" class="headerlink" title="实施挑战"></a>实施挑战</h2><ul>
<li>缺少对潜在价值的理解；</li>
<li>执行不到位；</li>
<li>改变管理的转变；</li>
<li>较低的使用价值；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;离开了物物交换以后，货币更多的作为一种价值载体，或是货币符号，一种信任符号，如果数字货币在不久的将来被较多人所信任能够作为价值的载体，区域链将大有可为，但也有较多挑战。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="商业区块链读书笔记" scheme="https://daiyongya.github.io/tags/%E5%95%86%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>另类币和加密货币生态系统</title>
    <link href="https://daiyongya.github.io/2017/07/01/%E5%8F%A6%E7%B1%BB%E5%B8%81%E5%92%8C%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F/"/>
    <id>https://daiyongya.github.io/2017/07/01/另类币和加密货币生态系统/</id>
    <published>2017-07-01T10:21:12.000Z</published>
    <updated>2017-11-14T12:38:26.188Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="另类币是什么"><a href="#另类币是什么" class="headerlink" title="另类币是什么"></a>另类币是什么</h2><p>另类币主要是修改了比特币相关的参数，比如修改了挖矿难度系统，每块区块链的大小或者改变了比特币挖矿算法或者共识算法后形成的币。<a id="more"></a>另类币相对没那么流行，矿工较少，最重要的任务就是吸引矿工，保证有足够的矿工进行挖矿以保证能给对区块链进行正确的共识，而不被少数矿工所控制。但是当另类币一定程度上流行起来以后，又会有人想要拉高价格出货，跟股票类似，叫PUMP-AND-DUMP SCAMS，所以另类币发展也困难重重。另类币创世块后，对币的分发主要有以下策略：</p>
<ol>
<li>预留或预售一部分能够快速启动另类币的群体；</li>
<li>给现有比特币的人群发放，条件是销毁或冻结等值比特币；</li>
<li>把初试另类币赠送出去，普及开；</li>
</ol>
<p>比如以下币种：<br><strong>域名币</strong></p>
<ul>
<li>把域名/数值对(name/value)作为录入数据；</li>
<li>只有首次录入者有权更改权限；<br>具体应用为，以后只需要在浏览器上输入baidu.bit即可访问百度。<br><strong>莱特币</strong>(lite coin)<br>和比特币最大的区别就是，莱特币采用了基于Scrypt算法的刚性内存(memory hard puzzles)解谜。<br><strong>比特币和另类币的关系</strong><br>有了比特币的普及以后，以后用户转向另类币也相对容易一些，何况另类币扩充了比特币的功能。</li>
</ul>
<h2 id="共同挖矿"><a href="#共同挖矿" class="headerlink" title="共同挖矿"></a>共同挖矿</h2><p>在另类币启动初期很容易被个人具有较大算力的矿工控制或者攻击，导致夭折。为了使另类币能够在比特币的基础上快速提高算力，有人利用比特币的基础设备对另类币进行共同挖矿，即同一套设备即可以产生比特币，也可以产生另类币，但此设备必须要使得交易记录在比特币和另类币中均有效，其中一种做法可以把另类币的交易概要放入比特币的币基交易里面。共同挖矿时候，可以计算出特殊的比特币区块，而此区块币基交易的输入脚本区域存有指向另类币区块的哈希指针，此区块身兼两职：</p>
<ol>
<li>对比特币客户端而言，此区块比较交易里面多了一个哈希值；</li>
<li>而另类币用户只会关注币基交易里面的哈希值。</li>
</ol>
<h2 id="以太坊及智能合约"><a href="#以太坊及智能合约" class="headerlink" title="以太坊及智能合约"></a>以太坊及智能合约</h2><p>以太坊是一种加密货币系统，致力于提供一种满足图灵计算要求的可编程语言，可以通过编写脚本或合约实现域名币等功能。在以太坊平台上，如果某人缴费(产生交易)以后，通过以太坊平台编写的代码或者合约，把付款人的域名和地址进行绑定，便实现了功能。<br>以太坊引入了循环语句，为了解决无限循环带来的系统性问题，以太坊引入了燃料费，对所有计算进行扣费，如果费用用完，计算自动结束，便规避了无限循环带来的负面影响，故以太坊暂时还不能支持过于复杂的运算。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;另类币是什么&quot;&gt;&lt;a href=&quot;#另类币是什么&quot; class=&quot;headerlink&quot; title=&quot;另类币是什么&quot;&gt;&lt;/a&gt;另类币是什么&lt;/h2&gt;&lt;p&gt;另类币主要是修改了比特币相关的参数，比如修改了挖矿难度系统，每块区块链的大小或者改变了比特币挖矿算法或者共识算法后形成的币。
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>比特币应用</title>
    <link href="https://daiyongya.github.io/2017/07/01/%E6%AF%94%E7%89%B9%E5%B8%81%E5%BA%94%E7%94%A8/"/>
    <id>https://daiyongya.github.io/2017/07/01/比特币应用/</id>
    <published>2017-07-01T04:18:50.000Z</published>
    <updated>2017-11-14T12:38:03.387Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="只增记录的应用"><a href="#只增记录的应用" class="headerlink" title="只增记录的应用"></a>只增记录的应用</h2><p><strong>安全时间戳及其应用</strong><br>secure timestamping，是利用比特币交易记录只可增加不可删除和更改的特性，对于一些需要证明却不能公布的事情进行备案记录。比如知道x数据，选一随机数r，进行$H(r||x)$哈希运算，然后广播于区域链上，可证明于公布时刻知道x但又未透露x具体细节，可用于专利证明。<br><a id="more"></a><br><strong>对未来事件预测</strong><br>某一些未来事件，比如有意身心健康的小赌，比如世界杯冠军预测，可提前把预测答案通过哈希运算，进行公布，最后出结果了再公布之前的预测结果。但是也存在一定漏洞，比如可以把所有可能的结果全部哈希运算后公布，最后只公布对的那个结果。也有人提出，可以通过报刊等公共媒体，比如把想要公布的内容刊登于某时间的报纸上，不过更多人认为还是比特币更好些，实现方式有几种，比如可以把想要公布的内容哈希运算，然后打很少的钱到此哈希地址去形成交易，然后记录。还有人提出可以用承诺币(commit coin)的方法，把内容生成一对私钥和公钥，用此公钥进行交易形成记录。<br><strong>op_return</strong><br>比特币有一个操作为$op\_return$，可以认为是一个函数调用，具体为$op\_return\langle H(data)\rangle$，此操作可因为返回错误代码而终止，但data由于产生了交易可以被记录下来，但是此方法需要产生一定的交易费。<br><strong>合约币</strong><br>合约币是一种附着币(overlay currencies)，以比特币为基础架构，把合约币的所有交易写入区块链，而不需要开发任何新的共识机制。</p>
<h2 id="智能资产"><a href="#智能资产" class="headerlink" title="智能资产"></a>智能资产</h2><p>数字签名的安全性，可以给物理货币，比如人民币增加其他价值。比如可以在人民币上数字签名，作为某电影票的进场凭证，如果不违法，因此发展除了一种货币，叫染色币。<br><strong>染色币</strong>(colored coins)<br>在某一交易里面，添加进一些元数据特征，以便于追踪验证或其他用处便是染色过程。染色币的应用有“开放资产”(open asset)。原理为：如果一笔交易选择了一个P2SH地址，通过此地址后，此币便被染上了一种特定颜色，公布地址后便有了意义。染色了的币可以作为博物馆入场券等。也有其缺点，包括：</p>
<ul>
<li>会产生交易费；</li>
<li>手机验证染色币较为困难；<br>染色比可以应用于以下场景：</li>
</ul>
<ol>
<li>股票交易，1染色币可以代表1股，股票交易即变为比特币之染色比交易；</li>
<li>物理使用权转换，比如汽车拥有权的交易；</li>
</ol>
<h2 id="打赌"><a href="#打赌" class="headerlink" title="打赌"></a>打赌</h2><p>如果三个人任意选择三个数，对三个数的余数进行打赌，</p>
<ol>
<li>选择一个打的任意数X,Y,Z，公布其哈希值H(X),H(Y),H(Z)，验证其具有明显差异；</li>
<li>披露X,Y,Z，履行赌约。<br>第一步不公布X,Y,Z而公布其哈希值，是证明了其已选择好了X,Y,Z且不会改变，保证赌约公平。在第二步，为了防止有人最后找理由不公布其值而终止比赛，可设定一时间并交保证金，如果规定时间内未披露其值，直接扣除保证金。<br><strong>未来币</strong>(future coin)<br>未来币是一种去中心化的预测技术，伪代码如下：</li>
<li>CreatMarket(event_id,arbitrator_key,num_outcome);</li>
<li>BuyPartfolio(event_id);</li>
<li>TradeShares();</li>
<li>SellPartfolio(event_id);</li>
<li>closeMarket();</li>
</ol>
<p>第一步CreatMarket如其意，可以对任何可以预测的结果创建一个赌约，然后授权arbitrator(可能是一个公钥)宣布结果执行赌约。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;只增记录的应用&quot;&gt;&lt;a href=&quot;#只增记录的应用&quot; class=&quot;headerlink&quot; title=&quot;只增记录的应用&quot;&gt;&lt;/a&gt;只增记录的应用&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;安全时间戳及其应用&lt;/strong&gt;&lt;br&gt;secure timestamping，是利用比特币交易记录只可增加不可删除和更改的特性，对于一些需要证明却不能公布的事情进行备案记录。比如知道x数据，选一随机数r，进行$H(r||x)$哈希运算，然后广播于区域链上，可证明于公布时刻知道x但又未透露x具体细节，可用于专利证明。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>其他挖矿算法</title>
    <link href="https://daiyongya.github.io/2017/06/30/%E5%85%B6%E4%BB%96%E6%8C%96%E7%9F%BF%E7%AE%97%E6%B3%95/"/>
    <id>https://daiyongya.github.io/2017/06/30/其他挖矿算法/</id>
    <published>2017-06-30T15:58:50.000Z</published>
    <updated>2017-11-14T12:38:42.091Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="挖矿算法基本要求"><a href="#挖矿算法基本要求" class="headerlink" title="挖矿算法基本要求"></a>挖矿算法基本要求</h2><p>可以作为挖矿的算法，必须具有以下性质：</p>
<ol>
<li>挖矿难度可调整，以保证计算力的增减不会导致挖矿速度急速变化；</li>
<li>挖矿结果可以快速验证；</li>
<li>能给买个矿工一定概率挖到矿，不然挖矿算力被控制以后将导致区块链出错；<a id="more"></a>
</li>
</ol>
<h2 id="反ASIC运动"><a href="#反ASIC运动" class="headerlink" title="反ASIC运动"></a>反ASIC运动</h2><p>现在的挖矿被强大的ASIC垄断，个人参与者参与感较低，早期对比特币设想的“一个CPU一票”机制难以实现，故掀起了一股反ASIC浪潮，目的是让每个用户都能参与到挖矿，以实现真正的去中心化。<br><strong>刚性内存解谜</strong>(memory-hard puzzles)<br>为了消弱ASIC带来得巨大算力优势，有人提出要用CPU算力的需求变换成对内存的需求，解谜成本的上升速率会随着内存提升速率一致，限制在一定水平。<br><strong>Scrypt</strong><br>它使刚性内存解谜算法，最早用于加密密码，后被莱特比采用用来挖矿，大致步骤如下：</p>
<ol>
<li>用随机数填充RAM缓存空间；</li>
<li>从RAM里面随机读取数据；<br>此算法需要选取足够大的数N来作为随机数的上限，但太大之后会增加挖矿难度。</li>
</ol>
<h2 id="有效工作证明"><a href="#有效工作证明" class="headerlink" title="有效工作证明"></a>有效工作证明</h2><p><strong>比特币解谜算法特点</strong>：</p>
<ol>
<li>解谜区域机会均等，不可预测；</li>
<li>解谜库永不枯竭；</li>
<li>谜题通过算法自动生成；<br><em>质数币</em><br>质数币算法也具有比特币的三个特征，但解谜算法已改变。质数币是为质数找到一个“坎宁安链”(CUNNINGHAM CHAIN)。大致过程为：K个质数序列 $P_1,P_2,…,P_k$ ,使得$P<em>k=2P</em> {k-1}+1$ ,找到一个非质数的和。</li>
</ol>
<h2 id="矿池利弊"><a href="#矿池利弊" class="headerlink" title="矿池利弊"></a>矿池利弊</h2><p>矿池的形成对矿工来说可能是一件好事，可以平摊风险，平摊收入，按照算力进行平摊。矿池需具有以下特性：</p>
<ol>
<li>矿工可以很容易通过公分来证明其工作量；</li>
<li>矿工必须按照矿池规则进行挖矿，而矿池作为整体收益，由于公钥被写进币基交易这点很容易办到。<br>但由于利益或者个人心情，部分矿工有可能挖到矿后不报导致作废，而还能得到公分，矿池将收到损失。如果增加一种协议，可以小额度奖励已经找到低等难度谜题答案的矿工，增加矿工的参与度而阻止矿池的形成。</li>
</ol>
<h2 id="虚拟挖矿"><a href="#虚拟挖矿" class="headerlink" title="虚拟挖矿"></a>虚拟挖矿</h2><p>virtual mining的提出是希望能降低挖矿的投入，减少能源浪费等，设计一种投票系统，选票由拥有币的数量决定，而不是算力，即所谓的”权益证明”。但挖矿成本的降低，也降低了故意的分叉成本，因为投入极大降低了，故形成了以下缺点：</p>
<ul>
<li>可以对挖矿能力今昔“蓄力”(save up)，可能导致分叉；</li>
<li>如果拥有51%筹码，可以只在自己认可的区域链上挖矿，控制整个区域链。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;挖矿算法基本要求&quot;&gt;&lt;a href=&quot;#挖矿算法基本要求&quot; class=&quot;headerlink&quot; title=&quot;挖矿算法基本要求&quot;&gt;&lt;/a&gt;挖矿算法基本要求&lt;/h2&gt;&lt;p&gt;可以作为挖矿的算法，必须具有以下性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挖矿难度可调整，以保证计算力的增减不会导致挖矿速度急速变化；&lt;/li&gt;
&lt;li&gt;挖矿结果可以快速验证；&lt;/li&gt;
&lt;li&gt;能给买个矿工一定概率挖到矿，不然挖矿算力被控制以后将导致区块链出错；
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>比特币利益相关主体</title>
    <link href="https://daiyongya.github.io/2017/06/30/%E6%AF%94%E7%89%B9%E5%B8%81%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E4%B8%BB%E4%BD%93/"/>
    <id>https://daiyongya.github.io/2017/06/30/比特币利益相关主体/</id>
    <published>2017-06-30T15:48:14.000Z</published>
    <updated>2017-11-14T12:37:42.138Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="与比特币利益相关方有哪些"><a href="#与比特币利益相关方有哪些" class="headerlink" title="与比特币利益相关方有哪些"></a>与比特币利益相关方有哪些</h2><ul>
<li>bitcoin core主要开发人员决定了规则的共识；</li>
<li>矿工决定了对交易历史记录的共识；<a id="more"></a></li>
<li>投资人购买并持有比特币，是对比特币价格的共识；</li>
<li>商家及客户使用比特币进行交易，构成了比特币需求的共识；</li>
<li>交易服务商，比如支持比特币付款的网上商城，可能是最大需求方；</li>
</ul>
<h2 id="为什么需要政府监管"><a href="#为什么需要政府监管" class="headerlink" title="为什么需要政府监管"></a>为什么需要政府监管</h2><ul>
<li>比特币可以轻易饶过政府监管，比如跨境的资金转移，境内买入，境外卖出，轻易破之；</li>
<li>比特币的匿名性，使得各种犯罪，比如绑架勒索之类的更加难以追踪；</li>
</ul>
<h2 id="比特币实践经验"><a href="#比特币实践经验" class="headerlink" title="比特币实践经验"></a>比特币实践经验</h2><ul>
<li>完全的匿名性，即把现实世界和数字货币货币完全分离是极其困难的，可参考“丝绸之路”追捕过程；</li>
<li>执法人员仍然可以对资金去向进行监视和追踪，虽然具有难度；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;与比特币利益相关方有哪些&quot;&gt;&lt;a href=&quot;#与比特币利益相关方有哪些&quot; class=&quot;headerlink&quot; title=&quot;与比特币利益相关方有哪些&quot;&gt;&lt;/a&gt;与比特币利益相关方有哪些&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;bitcoin core主要开发人员决定了规则的共识；&lt;/li&gt;
&lt;li&gt;矿工决定了对交易历史记录的共识；
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>匿名性</title>
    <link href="https://daiyongya.github.io/2017/06/27/%E5%8C%BF%E5%90%8D%E6%80%A7/"/>
    <id>https://daiyongya.github.io/2017/06/27/匿名性/</id>
    <published>2017-06-27T15:35:44.000Z</published>
    <updated>2017-11-14T12:38:36.675Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="匿名常识"><a href="#匿名常识" class="headerlink" title="匿名常识"></a>匿名常识</h2><p>比特币匿名的两种解释：</p>
<ol>
<li>比特币的地址是公钥的哈希值，没有真实姓名等信息，是匿名；</li>
<li>地址本身是一种虚拟标识，应该是化名，而不是匿名。<a id="more"></a>
</li>
</ol>
<p><em>实质上，匿名性指的是无关联性(unlinkability)的化名</em>。<br>旁路攻击(side channels)<br>即使真实姓名和比特币地址无直接关联，一些其他信息也可暴露真实身份。比如关联微信状态信息和交易信息。关联以后便有机会找出私人身份，并查看所有交易。<br>无关联性的关键属性：</p>
<ul>
<li>同一用户不同地址不相关；</li>
<li>同一用户不同交易不相关；</li>
<li>同一交易交易双方不相关；</li>
</ul>
<p>第三条只能尽量避免，或者通过匿名集技术避免。为什么需要匿名呢？比特币账本是完全公开永久可追踪，如果匿名性不够好，将泄露所有交易隐私。比特币匿名性的目标是达到传统银行的匿名级别，后续超过。但匿名性与比特币本身的去中心化常常矛盾，需权衡处置。</p>
<h2 id="去匿名化方法"><a href="#去匿名化方法" class="headerlink" title="去匿名化方法"></a>去匿名化方法</h2><p>可通过合帐交易，形成地址簇(clustering of addresses)，逐渐去匿名化。比如对交易地址进行聚类，或者先发生交易，再进行聚类打标。<br><strong>辨识个人账户方法</strong></p>
<ul>
<li>直接交易，找出部分地址，再进行聚类；</li>
<li>通过服务提供商；</li>
<li>找出个人疏忽信息；</li>
</ul>
<h2 id="混币-mixing-进行匿名"><a href="#混币-mixing-进行匿名" class="headerlink" title="混币(mixing)进行匿名"></a>混币(mixing)进行匿名</h2><p>技术逻辑为使用中介进行交易。部分钱包可以进行混币，但内部会保留信息，也会透露个人信息。有服务商专门提供混币，但安全会依赖服务商。<br><strong>混币准则</strong></p>
<ul>
<li>可多重混币；</li>
<li>一致性交易，比如同样币值会的混币会降低匿名性；</li>
<li>客户端自动化混币；</li>
</ul>
<h2 id="分布式混币-Decentralized-mixing"><a href="#分布式混币-Decentralized-mixing" class="headerlink" title="分布式混币(Decentralized mixing)"></a>分布式混币(Decentralized mixing)</h2><p>分布式混币优势：</p>
<ul>
<li>不需要一个具有绝对公信力的混币服务商；</li>
<li>协议保证几乎不能盗币；</li>
</ul>
<p><strong>实现混币主要方案步骤</strong>：</p>
<ol>
<li>找到可以混币的交易对手作为节点；</li>
<li>交换输入输出地址；</li>
<li>建立交易；</li>
<li>发送交易细节，签名输出；</li>
<li>广播交易；</li>
</ol>
<h2 id="零币与零钞"><a href="#零币与零钞" class="headerlink" title="零币与零钞"></a>零币与零钞</h2><p>基础比(basecoin)概念，基础币和零币来回转换，保证新币与旧币的无关联性，将具有更好的匿名性。<br><strong>零知识验证</strong><br>如果能在不透露任何关键信息的情况下，能够证明一个声明是正确的，则具有零知识验证性质。比如不透露关键信息证明哈希谜题。<br>$H(X||\langle OTHER INPUTS\rangle)&lt;target$<br>即在不告知x的情况下证明哈希谜题。<br>而零币可作为中介，帮助完成交易，但零币与比特币直接不存在关联，加强匿名性。零币铸币过程如下：</p>
<ol>
<li>生存序列号S和随机密钥R；</li>
<li>计算COMMIT(S,R),这是一个承诺；</li>
<li>在S,R保密前提下，在区域链发布承诺，消耗一个比特币，产生零币；</li>
</ol>
<p>以下为消耗掉零币赎回比特币过程：</p>
<ol>
<li>创建“消费”交易，，包含S和零知识验证声明；</li>
<li>矿工验证零知识验证声明；</li>
<li>矿工查询S，保证未经使用；</li>
<li>赎回新币到指定地址；</li>
</ol>
<p>每一个新币有特定S，一旦公布便不能再使用此零币，防止双重支付。<br><strong>零钞</strong><br>零钞系统是加强版匿名系统，零钞系统的交易不会把交易金额等关键信息进行公布，密码学证据保证了币的拆分及合并合法，系统只会公布交易的存在性及验证零知识验证所需要的关键信息，具体参考ZK-SNARKS技术。<br><strong>匿名性的综合比较</strong></p>
<ol>
<li>比特币：容易被交易图谱分析；</li>
<li>人工混币：服务商与节点存在威胁；</li>
<li>多重混币/合币：旁路攻击危险；</li>
<li>零币：与比特币不兼容，存在旁路攻击；</li>
<li>零钞：与比特币不兼容，需要复杂的建立流程。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;匿名常识&quot;&gt;&lt;a href=&quot;#匿名常识&quot; class=&quot;headerlink&quot; title=&quot;匿名常识&quot;&gt;&lt;/a&gt;匿名常识&lt;/h2&gt;&lt;p&gt;比特币匿名的两种解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比特币的地址是公钥的哈希值，没有真实姓名等信息，是匿名；&lt;/li&gt;
&lt;li&gt;地址本身是一种虚拟标识，应该是化名，而不是匿名。
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>比特币挖矿</title>
    <link href="https://daiyongya.github.io/2017/06/27/%E6%AF%94%E7%89%B9%E5%B8%81%E6%8C%96%E7%9F%BF/"/>
    <id>https://daiyongya.github.io/2017/06/27/比特币挖矿/</id>
    <published>2017-06-27T15:00:47.000Z</published>
    <updated>2017-11-14T12:37:51.434Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="挖矿-bitcoin-mining-任务"><a href="#挖矿-bitcoin-mining-任务" class="headerlink" title="挖矿(bitcoin mining)任务"></a>挖矿(bitcoin mining)任务</h2><p>加入比特币网络，然后完成以下任务：</p>
<ol>
<li>监听交易广播，验证交易；</li>
<li>维护区块链网络和监听新的区块链，验证；</li>
<li>组装备选区块链；<a id="more"></a></li>
<li>找到有效随机数使得新的区块链有效；</li>
<li>广播新区块链使得被接受；</li>
<li>获得利润</li>
</ol>
<p><strong>如何寻找有效区块</strong><br>矿工任务为组织新的交易，形成梅克尔树，并让头部指针指向上一区块，尝试随机数使得整个区块链哈希值小于目标值，则挖矿成功。可改变的随机树包括区块头部的32位随机数，及区块内部币基交易的随机数。<br><strong>挖矿难度的设置</strong><br>每产生2016个区块，挖矿难度重新计算，以保证平均每10分钟产生一个区块。</p>
<h2 id="挖矿硬件的改变"><a href="#挖矿硬件的改变" class="headerlink" title="挖矿硬件的改变"></a>挖矿硬件的改变</h2><p>挖矿实质上是对SHA256函数的运算，从一开始从CPU，GPU，到FPGA，到现在的ASIC专用集成电路，小矿工生存空间越来越小。</p>
<h2 id="矿池的形成及规则"><a href="#矿池的形成及规则" class="headerlink" title="矿池的形成及规则"></a>矿池的形成及规则</h2><p>由于过多专业玩家的加入，中小玩家生存空间越来越小。中小玩家为了生存，大玩家为了更加垄断，形成了抱团挖矿，即所谓的矿池。矿池运营基本模式为按照公分进行分工。什么是公分呢，比如新产生的哈希值前面是70个0，而某矿工找到了60个0的哈希值，此矿池的规则是大于55个0则计入公分，此矿工便拥有了一公分。如果此矿池挖到了新矿，则按照公分进行分红，部分矿池甚至每挖到一个公分就给矿工分钱。</p>
<h2 id="挖矿激励及策略"><a href="#挖矿激励及策略" class="headerlink" title="挖矿激励及策略"></a>挖矿激励及策略</h2><p><strong>矿池中的矿工面临的几个问题</strong></p>
<ul>
<li>需包含哪些交易；</li>
<li>对哪个区块进行挖矿；</li>
<li>如果同时出现两个新区块，如何进行选择；</li>
<li>什么时候宣布新区块；</li>
</ul>
<p><strong>分叉攻击</strong>(forking attack)<br>分叉攻击是在最后一个区块之前进行挖矿。当算力超过50%时，被分叉的区块超过了最长区块，会导致双重支付。当然也可通过贿赂具有算力的矿池进行攻击。<br><strong>临时保留区攻击</strong>(temporary block withholding attacks)<br>在矿池里，由于利益关系，部分矿工或矿池可能冒险，当区块被发现时不宣布，等到第二块区块发现时才宣布，中间时间如果有被发现的其他区块则会作废。<br><strong>黑名单与惩罚分叉攻击</strong>(punitive forking)<br>如果某矿工或矿池掌握绝对算力，可拒绝某一用户交易，导致此用户比特币不可用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;挖矿-bitcoin-mining-任务&quot;&gt;&lt;a href=&quot;#挖矿-bitcoin-mining-任务&quot; class=&quot;headerlink&quot; title=&quot;挖矿(bitcoin mining)任务&quot;&gt;&lt;/a&gt;挖矿(bitcoin mining)任务&lt;/h2&gt;&lt;p&gt;加入比特币网络，然后完成以下任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监听交易广播，验证交易；&lt;/li&gt;
&lt;li&gt;维护区块链网络和监听新的区块链，验证；&lt;/li&gt;
&lt;li&gt;组装备选区块链；
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>比特币的存储和使用</title>
    <link href="https://daiyongya.github.io/2017/06/27/%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>https://daiyongya.github.io/2017/06/27/比特币的存储和使用/</id>
    <published>2017-06-27T13:43:06.000Z</published>
    <updated>2017-11-14T12:37:32.548Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>存储和管理比特币的实质是对私钥的管理，其三个目标是：可获取行、安全性、便利性。<br><a id="more"></a></p>
<h2 id="简化存储与交易"><a href="#简化存储与交易" class="headerlink" title="简化存储与交易"></a>简化存储与交易</h2><p>比特币钱包软件可提供给用户易用的收款付款UI，而把实现细节隐藏在后台，亦可通过哈希地址甚至哈希地址的二维码进行付款。</p>
<h2 id="私钥存储方式"><a href="#私钥存储方式" class="headerlink" title="私钥存储方式"></a>私钥存储方式</h2><p>可分为热存储与冷存储。存储介质长期在线的属于热存储，离线的是冷存储，可用热存储管理零钱，冷存储管理大额币值。<br><strong>分层确定性钱包</strong>(hierarchical deterministic wallet)<br>为了使冷存储尽量不上线就能以不同的地址接受比特币而不暴露其他信息，可用随机数生产公钥和私钥，使得冷热存储地址信息同步，原理如下：<br>假设k,y为随机数，i为第i层地址，有：</p>
<ul>
<li>私钥生成信息：$k,x,y$；</li>
<li>第i个私钥：$x=y+H(k||i)$；</li>
<li>地址生成信息： $k,g^y$;</li>
<li>第i个公钥：$g^{x_i}=g^{H(k||i)}*g^y$</li>
<li>第i个地址：$H（g^{x_i}）$</li>
</ul>
<p><em>大脑钱包</em>(brain wallet)<br>把口令生成一对公钥/私钥，用口令进行管理。<br><em>纸钱包</em><br>把密匙印在纸上，纸锁在保险柜里(有点意思)。<br><em>防损硬件</em>(tamper-resistant device)<br>用硬件保存密匙或者生成密匙，类似于以前办理网上银行时候，银行给的电子密匙。</p>
<h2 id="密匙分存和共享"><a href="#密匙分存和共享" class="headerlink" title="密匙分存和共享"></a>密匙分存和共享</h2><p><strong>密匙分存</strong><br>原理为把密钥分成N份，只要获得其中K份，可还原密钥。比如把一个密钥分成两份，若S为密钥，生成随机数R，运算$ S\oplus R$生成另外一个随机数，我们可以把R作为密钥，$ S\oplus R$作为密文，只知道其中一个都无法得到S，同时得到后再以后才可还原S。<br><strong>密文生成规则</strong><br>根据拉格朗日公式，回归自由度为K-1的曲线，需要K个点。同理，如果使用自由度为K-1的曲线上的点进行分存，为了还原密钥，需要知道K个点。<br><strong>门限密码</strong>(treshold cryptography)<br>treshold signature技术原理举例，比如两份密码，一份存电脑，一份存手机，先由电脑同意交易后传递给手机，手机确认后方可交易，即需要同时签名。</p>
<h2 id="在线钱包和交易所"><a href="#在线钱包和交易所" class="headerlink" title="在线钱包和交易所"></a>在线钱包和交易所</h2><p>比特币交易所三大风险：挤兑、庞氏骗局及黑客入侵。为了防止挤兑，有时需要交易所披露存款规模，可通过梅克尔树对每个用户存款进行组织，每个叶子代表一个用户存款信息，汇总到根节点，如果根节点哈希值正确则可保证总存款无误。</p>
<h2 id="交易费"><a href="#交易费" class="headerlink" title="交易费"></a>交易费</h2><p>比特币交易有时需要交易费，如果一笔交易输入大于输出，差额则为交易费，由矿工收入。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;存储和管理比特币的实质是对私钥的管理，其三个目标是：可获取行、安全性、便利性。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>比特币运行机制</title>
    <link href="https://daiyongya.github.io/2017/06/24/%E6%AF%94%E7%89%B9%E5%B8%81%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://daiyongya.github.io/2017/06/24/比特币运行机制/</id>
    <published>2017-06-24T15:44:10.000Z</published>
    <updated>2017-11-14T12:38:14.306Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="比特币的交易"><a href="#比特币的交易" class="headerlink" title="比特币的交易"></a>比特币的交易</h2><p>每笔交易包括输入、输出和唯一的识别ID，其中造币交易没有输入，只有输出，其他每笔交易必须引用币的ID来阐明来源。且每笔交易要么不消耗比特币，要么消耗完比特币，可把剩余的比特币输出给自己的另外一个地址，此时需要地址转换。<br><strong>交易验证</strong>：通过哈希指针来验证交易合法性，输出是否等于上一笔交易的剩余值，是否双重支付等。<br><strong>共同支付</strong>：可两个输入，一个输出，并由两个输入者共同签名进行支付。<br><a id="more"></a><br>交易数据数据结构：</p>
<ol>
<li>元数据，包括数据版本、格式等；</li>
<li>输入，上一笔交易的地址及签名；</li>
<li>输出，交易数目及交易对方的地址(公钥)；</li>
</ol>
<h2 id="比特币脚本"><a href="#比特币脚本" class="headerlink" title="比特币脚本"></a>比特币脚本</h2><p>比特币脚本为堆栈式脚本，不是图灵完备的，只能被执行一次，无法循环执行。脚本包括：</p>
<ul>
<li>上一笔交易的地址(公钥)及签名；</li>
<li>各种操作，包括验证公钥及签名等；</li>
</ul>
<h2 id="比特币脚本应用"><a href="#比特币脚本应用" class="headerlink" title="比特币脚本应用"></a>比特币脚本应用</h2><p><strong>第三方支付交易</strong>(escrow transaction)<br>由买方、卖方、仲裁方组成交易三方，交易只需两方签名即可完成，正常情况由买卖双方签名达成交易，产生矛盾由卖方或者买方加上仲裁方签名完成交易。<br><strong>绿色地址</strong>(green addresses)<br>由于比特币验证时间较长，某担保方可进行担保，买卖双方进行瞬时交易，其他较慢的确认等动作由担保法完成，担保法地址为绿色地址。<br><strong>小额支付</strong><br>比如手机流量支付，买方可每分钟进行签名确认费用，最用一分钟买方确认后由卖方进行确认并断开服务完成交易，避免太过频繁的交易记录。</p>
<h2 id="比特币区块"><a href="#比特币区块" class="headerlink" title="比特币区块"></a>比特币区块</h2><p>由区块头部哈希指针指向上一区块，由梅克尔树组织区块内交易，每个区块内包含币基交易，用于生产比特币，以奖励矿工。</p>
<h2 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h2><ol>
<li>加入网络：向知道的种子交换信息以加入网络；</li>
<li>发起交易：泛洪(flooding)算法广播交易；</li>
<li>检验交易：验证交易有效性</li>
</ol>
<p>竞态情况(race condition)<br>当双重支付时，某节点会接收同一币源的比特币交易信息，以先到为有效拒绝后到。</p>
<h2 id="比特币机制的限制与优化"><a href="#比特币机制的限制与优化" class="headerlink" title="比特币机制的限制与优化"></a>比特币机制的限制与优化</h2><p>限制：大小为1M，一个区块最多4000个交易，平均10分钟产生一个区块，每秒钟处理7个交易。<br><strong>协议修改及软硬分叉</strong>：</p>
<ul>
<li>硬分叉：当新旧协议完全不兼容时候，未更新协议的节点会遵从旧协议选中最长区域链分支，新协议则另起一分支产生分叉；</li>
<li>软分叉：当新协议部分兼容旧协议时候，某一些区块满足旧协议未满足新协议造成小分叉；</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;比特币的交易&quot;&gt;&lt;a href=&quot;#比特币的交易&quot; class=&quot;headerlink&quot; title=&quot;比特币的交易&quot;&gt;&lt;/a&gt;比特币的交易&lt;/h2&gt;&lt;p&gt;每笔交易包括输入、输出和唯一的识别ID，其中造币交易没有输入，只有输出，其他每笔交易必须引用币的ID来阐明来源。且每笔交易要么不消耗比特币，要么消耗完比特币，可把剩余的比特币输出给自己的另外一个地址，此时需要地址转换。&lt;br&gt;&lt;strong&gt;交易验证&lt;/strong&gt;：通过哈希指针来验证交易合法性，输出是否等于上一笔交易的剩余值，是否双重支付等。&lt;br&gt;&lt;strong&gt;共同支付&lt;/strong&gt;：可两个输入，一个输出，并由两个输入者共同签名进行支付。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数字货币去中心化</title>
    <link href="https://daiyongya.github.io/2017/06/24/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96/"/>
    <id>https://daiyongya.github.io/2017/06/24/数字货币去中心化/</id>
    <published>2017-06-24T14:49:15.000Z</published>
    <updated>2017-11-14T12:39:09.843Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="如何判断是否中心化"><a href="#如何判断是否中心化" class="headerlink" title="如何判断是否中心化"></a>如何判断是否中心化</h2><ul>
<li>谁来维护交易账本；</li>
<li>谁来审核交易的有效性；</li>
<li>谁来造币；</li>
<li>谁来制定系统变化规则；</li>
<li>如何取得交易价值；<a id="more"></a>
</li>
</ul>
<h2 id="分布式共识-distributed-consensus"><a href="#分布式共识-distributed-consensus" class="headerlink" title="分布式共识(distributed consensus)"></a>分布式共识(distributed consensus)</h2><p>分布式共识是在很多人存在情况下，对某件事情如何达成一个共识。共识的输入值必须由诚实节点生成及决定。<br><strong>所有人都参与共识的难题</strong>：</p>
<ol>
<li>部分节点死机或者是恶意的；</li>
<li>p2p网络不稳定，如果需要所有节点达成共识不现实；</li>
<li>互联网严重延迟；</li>
</ol>
<p>包括<strong>拜占庭问题</strong>(Byzantine Generals problem)及<strong>Ficher-lynch-Paterson</strong>说明了共识问题的难度，而比特币特意的做法为：</p>
<ul>
<li>引入奖励，以利益驱动诚实，提高作弊成本；</li>
<li>引入随机概率；</li>
</ul>
<h2 id="比特币的共识问题"><a href="#比特币的共识问题" class="headerlink" title="比特币的共识问题"></a>比特币的共识问题</h2><p>隐形共识(implicit consensus)步骤：</p>
<ol>
<li>广播新产生的交易；</li>
<li>节点把交易放进一个区块；</li>
<li>每个回合，某一个随机节点可以广播自己找到的区块；</li>
<li>其他区块接受符合规则的区块并把哈希值放进自己的区块；</li>
</ol>
<p>比特币存在的安全问题：</p>
<ul>
<li>窃取比特币，由于无法伪造数字签名，通常会失败；</li>
<li>拒绝服务攻击，由于服务任何节点都可提供，通常会失败；</li>
<li>双重支付，由多重确认机制确保。</li>
</ul>
<h2 id="奖励机制与工作量证明"><a href="#奖励机制与工作量证明" class="headerlink" title="奖励机制与工作量证明"></a>奖励机制与工作量证明</h2><p>比特币采用了奖励机制及工作量证明，其奖励种类如下：</p>
<ul>
<li>造币奖励；</li>
<li>交易奖励；</li>
</ul>
<p><strong>工作量证明</strong>：</p>
<ul>
<li>计算能力所占比例决定了节点被选中造币的概率；</li>
<li>比特币采用了哈希函数解谜来证明工作量；</li>
</ul>
<p>哈希谜题：H(nounce||pre_hash||tx||….||tx)&lt;target<br>哈希谜题三个特性：</p>
<ol>
<li>难于计算；</li>
<li>量化成本；</li>
<li>易于证实；</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;如何判断是否中心化&quot;&gt;&lt;a href=&quot;#如何判断是否中心化&quot; class=&quot;headerlink&quot; title=&quot;如何判断是否中心化&quot;&gt;&lt;/a&gt;如何判断是否中心化&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;谁来维护交易账本；&lt;/li&gt;
&lt;li&gt;谁来审核交易的有效性；&lt;/li&gt;
&lt;li&gt;谁来造币；&lt;/li&gt;
&lt;li&gt;谁来制定系统变化规则；&lt;/li&gt;
&lt;li&gt;如何取得交易价值；
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>密码货币概述</title>
    <link href="https://daiyongya.github.io/2017/06/24/%E5%AF%86%E7%A0%81%E8%B4%A7%E5%B8%81%E6%A6%82%E8%BF%B0/"/>
    <id>https://daiyongya.github.io/2017/06/24/密码货币概述/</id>
    <published>2017-06-24T14:08:22.000Z</published>
    <updated>2017-11-14T12:38:31.493Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="密码学之哈希函数"><a href="#密码学之哈希函数" class="headerlink" title="密码学之哈希函数"></a>密码学之哈希函数</h2><p><strong>定义</strong>：输入为任意位数数值，经过某一函数后，输出为固定位数数值，这个函数必须具有以下三大特性：</p>
<ul>
<li><strong>碰撞阻力</strong>：不能存在不同输入得到相同输出；</li>
<li><strong>隐秘性</strong>：输入函数如果有一个高阶最小熵数值和固定输入数值组成，通过输出函数不能倒推出输入数值；</li>
<li><strong>谜题友好</strong>：在可执行时间内找到输入数值，保证通过哈希函数后产生一定条件的输出数值；<a id="more"></a>
</li>
</ul>
<h2 id="哈希指针及及其数据结构"><a href="#哈希指针及及其数据结构" class="headerlink" title="哈希指针及及其数据结构"></a>哈希指针及及其数据结构</h2><p><strong>哈希指针定义</strong> (hash pointer)：</p>
<ol>
<li>普通指针；  </li>
<li>指针值为某输入数值哈希值；</li>
</ol>
<p><strong>区块链定义</strong> (block chain)：</p>
<ol>
<li>普通链表；  </li>
<li>指针采用哈希指针；  </li>
<li>第一块BLOCK为genesis block，无法更改；</li>
</ol>
<p><strong>梅克尔树</strong> (merkle trees)：</p>
<ol>
<li>二叉树；  </li>
<li>树的叶子包含数据及左右子节点哈希指针；</li>
<li>根节点哈希值即可防止数据篡改；</li>
</ol>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p><strong>特性</strong>：</p>
<ol>
<li>保证只有自己可以签名，即签名的唯一性；</li>
<li>签名与每一文件一一对应，不可复制使用；</li>
</ol>
<p><strong>数字签名方案</strong>：</p>
<ol>
<li>(sk,pk)=generatekeys(keysize);</li>
<li>sig:=sign(sk,message);</li>
<li>isValid:=verify(pk,message,sig);<br>公钥(pk)的哈希值可作为身份使用，即公钥即身份。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;密码学之哈希函数&quot;&gt;&lt;a href=&quot;#密码学之哈希函数&quot; class=&quot;headerlink&quot; title=&quot;密码学之哈希函数&quot;&gt;&lt;/a&gt;密码学之哈希函数&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：输入为任意位数数值，经过某一函数后，输出为固定位数数值，这个函数必须具有以下三大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;碰撞阻力&lt;/strong&gt;：不能存在不同输入得到相同输出；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐秘性&lt;/strong&gt;：输入函数如果有一个高阶最小熵数值和固定输入数值组成，通过输出函数不能倒推出输入数值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;谜题友好&lt;/strong&gt;：在可执行时间内找到输入数值，保证通过哈希函数后产生一定条件的输出数值；
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链技术驱动金融读书笔记" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E9%A9%B1%E5%8A%A8%E9%87%91%E8%9E%8D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>国内区域链技术发展</title>
    <link href="https://daiyongya.github.io/2017/06/06/%E5%9B%BD%E5%86%85%E5%8C%BA%E5%9F%9F%E9%93%BE%E6%8A%80%E6%9C%AF%E6%83%85%E5%86%B5/"/>
    <id>https://daiyongya.github.io/2017/06/06/国内区域链技术情况/</id>
    <published>2017-06-06T13:12:04.000Z</published>
    <updated>2017-11-14T12:38:19.621Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="国内实验室分布情况"><a href="#国内实验室分布情况" class="headerlink" title="国内实验室分布情况"></a>国内实验室分布情况</h2><ul>
<li><strong>以政府为主体</strong>：如成都天府区域链创新实验室；</li>
<li><strong>以企业为主体</strong>：如西南国际、远光、万向中关村、乐视金融、前海国际等；</li>
<li><strong>以院校为主体</strong>：北航、浙大、中央财经等；</li>
<li><strong>以企业为主体</strong>：占绝大多数。<a id="more"></a>
</li>
</ul>
<h2 id="七大问题"><a href="#七大问题" class="headerlink" title="七大问题"></a>七大问题</h2><ul>
<li><strong>团队小</strong>：中小企业较多，即便是大企业，参与人数也较少；</li>
<li><strong>技术弱</strong>：实验室或公司发起人大多是企业家、投资人，缺乏专业技术研究队伍，可招聘专业人员亦较少；</li>
<li><strong>团队不稳定</strong>：团队不稳定，人流流动性大；</li>
<li><strong>缺乏经费</strong>：较多实验室无明确资金来源，企业缺乏大量风头；</li>
<li><strong>缺乏权威成果报告</strong>：国内实验室较少权威成果发布；</li>
<li><strong>投资人缺乏专业知识</strong>：风头及政府都有炒作跟风嫌疑，缺乏实质性的技术积累；</li>
</ul>
<hr>
<p>区域链发展需踏实做事之人，少些浑水摸鱼，炒作敛钱的人。可以以垂直市场为突破口，找到一个既可以沉淀技术也可以变现维持，待厚积薄发的方向。</p>
<blockquote>
<p>中国的区域链为何走不出实验室？–新浪财经<br>(<a href="https://cj.sina.com.cn/article/detail/5617250671/115675" target="_blank" rel="external">https://cj.sina.com.cn/article/detail/5617250671/115675</a>)</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;国内实验室分布情况&quot;&gt;&lt;a href=&quot;#国内实验室分布情况&quot; class=&quot;headerlink&quot; title=&quot;国内实验室分布情况&quot;&gt;&lt;/a&gt;国内实验室分布情况&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以政府为主体&lt;/strong&gt;：如成都天府区域链创新实验室；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以企业为主体&lt;/strong&gt;：如西南国际、远光、万向中关村、乐视金融、前海国际等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以院校为主体&lt;/strong&gt;：北航、浙大、中央财经等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;以企业为主体&lt;/strong&gt;：占绝大多数。
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区域链" scheme="https://daiyongya.github.io/tags/%E5%8C%BA%E5%9F%9F%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>如何证明你妈是你妈</title>
    <link href="https://daiyongya.github.io/2017/06/03/%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E4%BD%A0%E5%A6%88%E6%98%AF%E4%BD%A0%E5%A6%88/"/>
    <id>https://daiyongya.github.io/2017/06/03/如何证明你妈是你妈/</id>
    <published>2017-06-03T14:10:48.000Z</published>
    <updated>2017-11-14T12:39:03.426Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>貌似记得是亲民的总理提出，需要简化行政手续，减少证明你妈是你妈的问题，由此热议了一段时间。最近两天几天新闻又爆料某女士需要证明她妈是她妈，作为入住GITHUB的第一篇博客，浅谈下个人看法。<br><a id="more"></a></p>
<h2 id="各方理由"><a href="#各方理由" class="headerlink" title="各方理由"></a>各方理由</h2><p>媒体热议可能是出自于自身曝光率的需求，曝光率的需求证明了也是人民的需求，人民的确觉得麻烦，很多人都遭遇过此类情况，或者遭遇过其他行政情况，一看到便会有共振，而政府呢，出发点至少应该是为了尽量不犯错出发，证明流程多了，人民办事成本高了，工作人员犯错成本低了。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>此问题特点，户籍问题，树形算法问题，无回路，各种分支，需保证无法伪造，append-only特性。利用区域链技术可实现。</p>
<h3 id="生活内容作为加密输入"><a href="#生活内容作为加密输入" class="headerlink" title="生活内容作为加密输入"></a>生活内容作为加密输入</h3><p>以人物内容为蓝本提取人物标签或者特征值，加随机数，生成哈希指针，哈希指针作为后代身份认证内容的指针和父辈内容的验证。后续加入的身份递推。但是人物内容的标签或者特征值制定需探讨。</p>
<h3 id="DNA作为加密内容输入"><a href="#DNA作为加密内容输入" class="headerlink" title="DNA作为加密内容输入"></a>DNA作为加密内容输入</h3><p>以DNA特征值作为输入，生成哈希指针，由于DNA的唯一性保证了哈希指针的唯一性，后代内容递推。</p>
<p>具体原理可参考哈希指针和区域链相关技术，较多需追溯无闭环的问题可考虑用特殊数据结构进行改造，减少行政成本，经营成本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;问题的提出&quot;&gt;&lt;a href=&quot;#问题的提出&quot; class=&quot;headerlink&quot; title=&quot;问题的提出&quot;&gt;&lt;/a&gt;问题的提出&lt;/h2&gt;&lt;p&gt;貌似记得是亲民的总理提出，需要简化行政手续，减少证明你妈是你妈的问题，由此热议了一段时间。最近两天几天新闻又爆料某女士需要证明她妈是她妈，作为入住GITHUB的第一篇博客，浅谈下个人看法。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://daiyongya.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="商业区块链读书笔记" scheme="https://daiyongya.github.io/tags/%E5%95%86%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
